* In TypedAST.ValDeclaration - getILValueType, shall we need to guarantee if defintion is Fn, the declType should not be null. Not sure if we still use TypedAST. When shall I took this check.
* do we also need to consider the assignment to var variable for the typeless lambda expression
* In current Wyvern's lambda implementation, does the Type used as a lambda type should only have one method with fixed name "apply"? (Not like Java that any interface with only one method can be used as a lambda type)
* In the Parser, we used Formals() both in Def's declaration and lambda expression. So when we change Formals, we also let Def's declaration open to issue with implicit argument. So we need to add checks here, right?(where shall we do this check? in generateIL or in Wyvern IL)


* In WyvernParser.jj, we use ```Formals()``` both in ```DefDeclaration()```, ```DefDeclType()``` and ```LambdaFn()``` . So when we change Formals, we also let ```DefDeclaration()``` open to issue of argument missing type. So we might need checks in ```DefDeclaration()```, right? Then another question is when shall we put the check logic? in TypedAST or Wyvern IL? I'm not sure if the TypedAST.typecheck(...) is still in use/  
* In current Wyvern's lambda implementation, does the Type used as a lambda type must have only one method with fixed name "apply"? (Not like Java that any interface with only one method can be used as a lambda type)
* I think in an Assignment to a ```var``` varialbe, we also need to consider the lambda inferred.
* As you suggest, we do the lambda inferred in generateIL method and when we found the declare type is missing, we report error here. My question is shall we do the declare type checking in transformation or we postpone it latter to do the typecheck in Wyvern IL's typecheck? If we do it in transformation, our typecheck logic will reside both in Wyvern IL and transformation and made future maintain more difficult.
